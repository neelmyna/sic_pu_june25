SIC TRAINING PRESIDENCY UNIVERSITY BENGALURU

DAY1 MONDAY 23-06-2025
Github Repo creation
	Login to github
	On top mid screen Click +
	Click New Repository
	In new window, name of the repo, description, keep the repo public and select add readme file and click create repo green button
	
We are going to link our Git Repo on our system.
We are going to create a copy of the Git Repo in our system which we shall call as local Repo.
Now to work on the local Repo, we have to 1st link our Git Account with our computer (configuration)
Now we can work on the Local Repo. However, if we have to update the Remote Repo (server) w.r.t. the local Repo we have top authenticate everytime.
To avoid authentication for every PUSH, we can use PAT (Personal Access Token).

STEPS TO CREATE PAT:
Right top corner of logged-in page, click the profile icon
Scroll down and click settings
next page, scroll down and click developer settings (left bottyom)
next page, left top, click personal access token (select tokens classic)
next page, click generate new token, select classic
next page, add note (this PAT is created for my personal learning during my engg days)
Click Expiration, select No Expiry
Now select the top check box named Repo
Now fully scroll down and click generate PAT button
Next page, copy the PAT and Mail it to yourself (mail subject: git pat). So that the PAT is always with you and also safely.
--------------------------------------------------
DAY2 TUESDAY 24-06-2025

TOPICS FOR THE DAY
Git, Python shell

APP INSTALATIONS:
Note: Always prefer Downloading installer/setup file (.msi)
1. vs code
Google search: Download vs code
Link: https://code.visualstudio.com/download
Click on respective OS

2. git
Google search: Download vs code
Link: https://git-scm.com/downloads
Click on respective OS

3. notepad++
Google search: Download vs code
Link: https://git-scm.com/downloads
Click 8.7.7 or 8.8 version
in new page, click the Box shaped download link.

4. python
Google search: Download python
Link: https://www.python.org/downloads/
Click the yellow button if your OS is Windows else select the OS

Note:
Now CUT and PASTE all the .msi files into their respective folders inside the software folder in C drive.

ORGANISING(ARRANGING FILES AND FOLDERS):
Create software folder in C drive and create one folder for every software or app you download.
Now cut and paste the installer files in to their respective folder inside the software folder in C drive.
Now from here doubl click and install the Apps.

Create a folder named "learning" in D or E drive. (if not available in C drive)
Now, inside the learning folder we create respective folders for java, python, cpp, cyber_security etc.

GIT CONFIGURATION:
$ git config --global user.name "neelmyna"
$ git config --global user.email "EMAIL-ID"

CLONING A REPO:
$ git clone https://github.com/neelmyna/sic_pu_june25

By running the above command, we get a copy(clone) of our repo in our system.

$ git clone https://PAT@github.com/neelmyna/sic_pu_june25

git clone https://3kjflrwkjljfdkjvskjvbsjkd@github.com/neelmyna/sic_pu_june25

IMPORTANT GIT COMMANDS:
To update my remote repo w.r.t. local repo:

1. Let the git add the files that need to updated
2. Let the git commit the changes (Here, git creates an object inside which it copies all the files that need to be updated into the server. Also this object is cyber secured with encription. This copy is called as soft copy)
3. Copy the commited object from the laptop/system to github server (to this last step, we need internet)

1. stage	2. commit 	3. push

$ git add .
$ git commit -m "relavant message"
$ git push origin main
---------------------------------------------
PYTHON

Python is very easy to read and understand.
It is written as similar to every day human life language.

Pyhton code:
if 4 in [1, 2, 3, 4]: print('There is 4')
Interpreted as:
if there is 4 among 1, 2, 3 and 4, print 'There is 4'

In every language, there 2 stages of a program (Compile time and runtime)

C/C++:
editing -> compilation -> execution
compilatiion: pre-processing (macro expansion) -> Compilation (syntax checking -> translation) -> interpretation -> execution

Operators in Python:
Arithmetic Operators:
+ - * / // ** %

-> All the Arithmetic operators are binary operators, i.e. they take 2 i/p (operands)
25 + 3
-> i/p are numbers. o/p is number
-> The arithmetic operations are performed from L to R in an expression. Associtivity
23 - 45 + 12 (Here 23 - 45 is performed 1st. the difference is stored in Accumalator and it is added to 12 immediately by the ALU).
-> + and - have least precedence
-> % / // * have higher precdedence
-> ** has the highest precedence
-> Arithmetic operators have higher precedence than relational operators and logical operators.

TYPES OF MEMORY
Secondary memory (hdd/ssd)
RAM
cache, buffers (unbuffered, line buffers and user customised delimited buffers), registers (general purpose, special purpose)
Special Purpose registers: MAR, MDR, SP, FP, IR, PC, Accumalator

scanf("%s", str); // space and newline are delimiters
gets_s("%s", str, 32); 
scanf("%[$^]s", str);
kbhit()

-> + and - have least precedence
-> % / // * have higher precdedence
-> ** has the highest precedence

34 + 45 * 5 ** 2
Here the power operation is performed 1st. Then multiplication and lastly the addition.

2 + 5 + 9 - 11 + 13
7 + 9 - 11 + 13
16 - 11 + 13
5 + 13
18

1 ** 2 ** 3 ** 2
1 ** 2 ** 9
1 ** 512
1

2.5 + 25
Here the sum operation cannot be performed unless 25 is casted to 25.0

Positive Integers are stored by converting them from decimal/octal/hexadecimal to binary
Negative numbers are stored by converting the number to binary and then to 2s compliment.
Floating point numbers are stored in binary using IEEE standards.

25 - (-13) + 4.5

13
0000 1101
1111 0010
1111 0011
-1*2(7) + 1*2(6) + 32 + 16 + 3
-128 + 64 + 32 + 19
-64 + 51
= -13

n = 0o25

0000
1111
15
f

ff
11111111
240 + 15 = 255

RELATIONAL OPERATORS:
> < >= <= != ==

-> All are binary operators
-> i/p are numbers. o/p is boolean
-> The >= and <= operators are looks redundant, but are required.

size = 20
Do the THIS size times
for i = 1 and i <= size, keep doing:
	THIS

for i = 1 and i < size+1, keep doing:
	THIS

for i = 1 and i <= 20, keep doing:
	THIS

for i = 1 and i < 21, keep doing:
	THIS

Thus the operators >= and <= increases the readability. Hence we use it.

***IMPORTANT: In programming the 1st priority (overall) is always simplicity (readability, maintainability)

[20, 40]	Closed interval The range is from 20 to 40 (both inclusive)
(15, 35)	Open Interval. The nd points are not included. So the range is 16 to 34
[25, 50)	Right Open. Range is 25 to 49

value >= 20 and value <= 40
value > 15 and value < 35
value >= 25 and value < 50

Relational operators have lesser precedence than Arithmetic but higher than logical operators.

LOGICAL OPERATORS:
and or not !

There is only short circuited "and" and "or" in Python

In C/C++/Java
C1 & C2 && C3

c1 and c2 and c3 ... c10

C:
int n = 10, m = 20, k = 15;
if(n++ >= m && k-- != m)
	print Goa
else
	print Bali
print n m k 
// Bali  11 20 15

int n = 20, m = 20, k = 15;
if(n++ <= m | k-- != m) T or F
	print Goa
else
	print Bali
print n m k 
// Goa 21 20 14
	
'3' - 48
51 - 48 = 3

str input()
str input(str)
NOTE: There is no function overloading in Python.
--------------------------------------------------------
DAY4 THURSDAY 26-06-2025

Mantra:
The code we define/implement must be understandable by any programmer in the world.

The O/P (execution) must be understandable by any common person in the world.

range() is a function in Python which takes a range of values and YIELDS the values one by one from the range depending on the increment.

range(10)
values the range yields are 0 to 9 with increment of +1
range(1, 20)
values the range yields are 1 to 19 with increment of +1
range(1, 20, 3)
values the range yields are 1 to 19 with increment of +3
range(21, 2, -3)
values the range yields are 21 to 3 with increment of -3

range()
input()
print()
len()
min()
max()
sorted()

Students Repo Links:
https://docs.google.com/spreadsheets/d/1iUklq9hEl6KcluwuOU18ECfiK45syp4NLX0EDcVMnTA/edit?gid=0#gid=0

https://github.com/neelmyna/sic_pu_june25
-----------------------------------------------------------------
DAY5 FRIDAY 27-06-2025

ARRAY/LIST:
-> It is a data structure in which all elements of the array are stored in continuous memory locations. i.e. there is no gap between any 2 consecutive elements of the array.
-> What is a Data Structure?
Ans: Storage + Arrangement of data in memory.
-> In the array usually all elements will be of the same DT. However, this need not true in the case of Python.
-> An array is time efficient DS. Because the look-up is O(1). i.e. it takes 1 unit time to access any element in an array.
-> Assuming size of an array is fixed, there is always wastage or shortage of memory. Hence fixed size arrays are always memory inefficient.
-> When ever we pass an array to a function/method we pass only reference (address of 1st element) of the rray. This kind of call to the function is called as call by reference.

List in Python:
-> It is an ordered DS (where we can use the indexing)
-> Mutable

List class in Python

Problems:
1. Find smallest and biggest elements in an list of n numbers.
2. Find the frequency an element in a list of n elements.
3. Remove the duplicates in a list of size n
**4. Given a number, find very next possible bigger number that has all the digits of the given number.
5. Accpet a number from the user (4 digit number where a digit can repeat at most 2 times )and print the coutn of recursions reqired to arrive at Karpekar's Constant.
Recursive Problems:
1. Find Factorial of a number
2. Print N Fibo terms with 1 and 2 as 1st 2 terms.
3. Find sum of list elements
-----------------------------------------------------------------
DAY6 SATURDAY 28-06-2025

List example programs 
l1 = [1, 2, 5, 2, 4, 3]
print(sorted(l1))
print(l1)
print(l1.remove(2))
--------------------------
List Slicing:

----------------------------------------
Implement Stack using list, insert and delete from rear of the list
Implement Stack using list, insert and delete from front of the list
Implement Queue using list, insert at rear delete from front the list
Implement Queue using list, insert front, delete from rear of the list
-------------------------
int num;
size = scanner.nextInt();
int[] numbers = new int[size];

void myFunction(Car car) {
	car.closeWindow();
	
	NewCar myCar = new Car();
}
----------------------------------------------
DAY-7 Monday 30-06-2025 

How inheritance is technically implemented?
Why a constructor cannot be final abstract and static?
Why main() is public static and void?
Explain runtime polymorphism (method over-riding).
What is collection and explain its use and memory mapping.

List Comprehension:
list is a DS in Python (pre defined). list is a class
list is ordered
list is mutable

l1 = [1, 43, 3, 2, 5]

l2 = [1, 2, 5, 4, 3]

name = 'shanmugha'

name.find('u')
name.find('mu', 2)
name.find('uu', 2, 7)
name.index('mugha', 3, 7)
------------------------------------------
original_str = 'college'

i++
j--
a[i] = b[j]
b[j]++

a[++i] = b[--j]++ // low cohesive
----------------------------------
2 servers
2 types of requests
allocation +ve number
deallocation -ve number

N
45  -13  -30  -10  50  35  -5  5  8
0         2         4

45 + (-30) + 50 + (-5) + 8
68 units of memory is allocated by server1
----------------------------------- 
Read N,  X  and Y
X + Y = N

numbers = []
Read N numbers in to numbers

sort numbers (ascending)
p = numbers[y] - nunmbers[y-1] - 1
print p

-------------------------------------------
def check_arrangement(b, g)
	arrangment = true
	for i in range(1, n):
		if girls[i] >= boys[i-1] and boys[i] >= girls[i-1]:
			continue # go to the next iteration
		else:
			arrangment = False
			break # Once we know such arrangment is not possible, quit
	if arrangment and (g[0] >= b[0] and g[-1] >= b[-1]) or (b[0] >= g[0] and b[-1] >= g[-1])
		return "yes"

Read T
output[]
	for T times do:
		Read N
		g[]
		b[]
		Read N heights of g[]
		Read N heights of b[]
		sort g[]
		sort b[]
		result = check_arrangement(b, g)
		output.append(result)
print output
----------------------------------------
DAY9 WEDNESDAY 02-07-2025

Bubble Sort:
In this sorting technique we start from any of the 2 ends of the list and compare consecutive elements.
Assuming we start from Left and wish to sort in scaending order, we swap the elements if the left element is bigger than the right one.
Continue doing so upto the end of UNSORTED ARRAY and thus we have put the biggest element in the unsorted array in its final position.
Thus the element is taken from the unsorted array into the sorted array.

RUN: Accessing all the elements in an array exactly once from one end of the array to the other.
In Bubble sort, we bring the element into its final position in one Run over the unsorted array.

Bubble sort doesnt predict anything before starting the sort algorithm nor it knows if the list is already sorted (i.e. after the 1st Run)

The biggest element of the specific Run is moved to its final position. This is called as BUBBLING the element to a corner.

While comparing the elements if we observe that there are no Swaps in a Run, then the list is already sorted.
Thus we have a way to optimize the Bubble Sort. The optimzed Bubble sort has an improved efficiency of O(n).

The Bubble Sort Algorithm:
Start from one end and move towards other end of unsorted array
	compare consecutive elements
	if left element is bigger than the right
		swap the elements

With each iteration of the Run, the size of sorted list increases by one while the size of unsorted array decreases by one element.

Pseudocode

Assume input size to be N
for i from 1 to N-1 do:
	for j from 1 to N-1-i do:
		if list[j] > list[j+1]
			swap list[j], list[j+1]

The outer loop Runs through the list (Accessing elements of the list exactly once)
The inner loop compares consecutive elements of the unsorted list

Optimized Bubble Sort:
for i from 1 to N-1 do:
	sorted = True # Assume the list is already sorted
	for j from 1 to N-1-i do:
		if list[j] > list[j+1]
			swap list[j], list[j+1]
			sorted = False
	if(sorted)
		break outer loop

BCE of improved(optimised) Bubble sort is O(n)
WCE of Bubble sort O(n2)


1 2 3 4 5 6 7 8 9 10
1  + 10 = 11
2  + 9  = 11

(1 + n) * (n / 2)
= 11 * 5 = 55

1 2 3 4 5 6 7 8 9.... 50
1 + 50 = 51
2 + 49 = 51

25+ 26 = 51
(1+50)*25 = 1275
----------------------------------
n-1 times the outer loop works
i=1  n-2 times
i=2  n-3 times
i=3  n-4

i=n-1  n=1
1 + 2 + 3 + .... n-3 + n-2 + n-1
n(n-1)/2
n2/2 - n/2
= n2/2
= n2

8000
3_20_00_000 - 4_000
= 3_20_00_000

The Bubble sort doesnt follow any specific mathematical formula or technique.
Its solution is what we find on day to day basis.
Thus it has come from centuries of commonly used problem solving technique (Trivial way of problem solving)
Which is said to come under BRUTE FORCE TECHNIQUE.
Thus In Brute Force technique there is Inventor Name.
---------------------------------------------
Selection Sort (Brute Force Technique)

23   4    1    33    22   19   50    25
i=1
element  = 23  4   1
position = 1   2   3
After the loop has excited, swap the elements at positions position and i
1   4    23    33    22   19   50    25
i=2
element  = 4 
position = 2
1   4    23    33    22   19   50    25
i=3
element  = 23  22  19 
position = 3   5    6
1  4  19  33  22  23  50  25

In each iteration of i, we SELECT the ith smallest element and put in its final position.

Thus, there are N-1 iterations for i
And N-1-i comparisons in each iteration of i

Assignment: Can we optimize Selection Sort the way we did with Bubble sort and thus bring the BCE of Selection sort from O(n2) to O(n)

NOTE: We need not apply any sorting on the given array when (when we know the given array is already sorted)

for i from 2 to N do:
	element = list[i-1]
	position = i-1
	for j = i-1 to N do:
		if list[j] < element then:
			element = list[j]
			position = j
	swap list[position] with list[i-1]
---------------------------------------
Quick Sort

CLASS_SIZE = 50
total_training_amount = training_fee * CLASS_SIZE

-------------------------------------
SESSION-11 03-07-2025 THURSDAY

employee:
	id, name, designation, phone_number, salary, commission, years_of_experience, technology

id				int			primary key auto_increment
name			varchar(30)	not null
designation		varchar(30)	
phone_number	bigint		unique
salary			float		
commission		float		default(0)
years_of_experience tinyint	
technology		varchar(30)	not null

create database nithin_db;
create table employees();

insert into employees()
20 rows/tuples 
5 rows must have all values
5 rows do not add some of the values
5 rows do not add all the values that we can skip
5 rows as you wish

CRUD OPERATIONS:
Create one row			post		
Read/Retrieve one/all	get  	(with id or without)
Update					put		(with id)
Delete					delete	(with id)

Chapter2 Assessment Link:
https://docs.google.com/forms/d/1ZD-UzOZW4RbdvV4h4k_UoCxmQaLfadbOjnSdwsItV2o/edit

---------------------------------------------------------------
OBJECT ORIENTED PROGRAMMING CONCEPTS:
Inheritance: 
polymorphism:
abstraction:
encapsulation:

super()
private members using _ (underscore)
inherit in Python 
class Derived (Base):

Parent most class in Python Obj
There is no compile time in Python. Hence no question of static polymorphism (function over loading)

When a Function is called:
Prologue
Business logic
Epilogue

static member:

class Cubical:
	str printer
	water_dispencer
	def __init__(self):
		chair
		mug
		computer
		drawer

	@static
	def get_printer(cls):
		return printer

-----------------------------------------------------------------------------
Tree:
-> TREE is a DS
-> Non Linear DS
-> ACYCLIC DS (All PATHs in the DS are unique)
-> The start/entry point of a Tree is called as ROOT
-> Synonym for Tree is HIERARCHICAL DS
Example: File System (Random Tree)
-> BINARY TREE is a Tree which has a maximum (at most) of 2 CHILD NODES for every possible NODE in the Tree.
-> The Root Node of the Tree is said to be at a LEVEL 1. Thus its immediate child node is at a LEVEL 2 and so on.
The maximum possible Level in a Tree is said be DEPTH or HEIGHT of the Tree.
In a Binary Tree of a Height N, we can have maximum of (2 power N) - 1 nodes.
TRAVERSAL in a Tree is when we move from the current node to one of its immediate child node.
A Tree with exactly or almost 2N-1 nodes is said to be COMPLETE BINARY TREE.
The 2 child nodes of a node in a binary tree are said to be LEFT-CHILD and RIGHT-CHILD
The Tree we can traverse strating from the Left-Child Node is said to be LEFT SUB-TREE and thus we can have Right Sub-Tree
In a Complete Binary tree (BT) every traversal will isolate or remove 50% of the search area.
If in a BT every node has exactly Zero or Two child nodes only, then such a BT is said to be STRICTLY BT.
If in a BT, the data is ARRANGED in such way that data of the left child of every node is smaller than its own data (data of Parent node) and data of the right child node is greater than or equal to its own data, then such a BT is called as BINARY SEARCH TREE (BST).
In a BST if the number of nodes is very small than 2N-1 (where N is tree height) then such a tree is said be UNBALANCED TREE. Conversly balanced tree and perfectly balanced is COMPLETE BST or BBST.
The highest level in a tree is the HEIGHT of the tree.
A node with  no child nodes is said to be LEAF NODE (Brahmachari node)
While traversing a BT when ever we reach a new node, it itself can be considered as Root and the nodes that can be reached from it as nodes of the tree. Thus to perform any operation on a BT, we always Traverse and while traversing (for traversal) we can apply the solution RECURSSIVELY.
Traversal exactly is to reach every node in the Tree exactly Once.
If you traverse the BT in the order Left-Root-Right (LR`R) then it is said to be In-Order traversal.
If you traverse the BT in the order Root-Left-Right (R`LR) then it is said to be In-Order traversal.
If you traverse the BT in the order Left-Right-Root (LRR`) then it is said to be In-Order traversal.
A new node is always added into the BST as Leaf Node.

Balancing a BST
Self balancing BST
Contructing a BST using 2 traversals 
CRUD operations

Deleting a node from a BST:
1. node with 0 child nodes 
2. node with 1 child nodes 
3. node with 2 child nodes
--------------------------------------------------------------------
SESSION-14  08-07-2025

https://docs.google.com/forms/d/1J2g0nOomI3mav_t2LzcTLgtID6Ne1KNHCt5oLullvQE/edit

def my_function(param1, param2 = 10):
    pass

def my_function2(param1 = 10, param2):
    pass

my_function(10)
my_function2(10)
-----------------------
def my_function(y):
	def inner_function(x):
		return x + y   # return x + 5
	return inner_function

closure = my_function(5)
print(closure(10)) # outputs 15

int num = 10;
int* ptr = NULL;
ptr = &num;

float my_func(int, char); // function declaration

float (*fp)(int, char); // function pointer declaration
fp = &my_func

A pointer of a specific DT can point any variable of that DT
A function pointer of a specific prototype(SIGNATURE) can point to any function of that particular signature.
----------------------------------------------------
Deletion of a node in a BST:
1. If the node to be deleted is leaf node:
	Make the respective link of the Parent node of the node being deleted None.
2. If node to be deleted has one child
	Replace the child node of the node being deleted with itself.
3. If node to be deleted has 2 children
	Make the right child of the node being deleted, the right child of its parent (Thus the right grand child become right child). The right child of the node being deleted replaces itself.
	And the left child node (and its descendents(sub tree)) becomes the left child of the left most child of its right child.
4. What is we are deleting the root itself (when it has 2 child nodes) ???
-------------------------------------------------------
PDB: Python debugger
Debugging is the skill of tracing the logic.
Tracing the logic is to halt the execution of the program at specified instructions and cheking the state of the program.
We do this by checking the values of the variables at certain specific instruction in the code.
For example, we set a break point at a certain instruction inside a loop and check the value of a particular variable to make sure it is changing its value as expected.

What we can achive via debugging:
1. We can check the values of the variables at any given point of time during Debugging
2. We can print the stack (call stack)
3. We can apply break points
4. We can apply check points
5. Match points
6. set points
7. jump into a function (step)
8. move to next instruction (next)

Command To run a python scrpit (program) in debug mode:
python -m pdb your_script_name.py

alternatively we can use the module pdb:
import pdb
pdb.set_trace()

import pdb
pdb.set_trace()

def check_palindrome(number): # call by value
    reverse_number = 0
    while number != 0:
        remainder_digit = number % 10
        number = number // 10
        reverse_number = reverse_number * 10 + remainder_digit
    return reverse_number

input_number = int(input('Enter a number to check if it is Palindroime: '))
reverse_number = check_palindrome(input_number)
if reverse_number == input_number:
    print('Palindrome')
else:
    print('Not a Palindrome')
-------------------------------------------------------
import numpy as np

array1 = np.zeros(3)
print(f'Array1 = {array1}')

array2 = np.zeros((1, 4))
print(f'Array2 = {array2}')

array3 = np.zeros((2, 5))
print(f'Array3 = {array3}')
---------------------------------------------
import numpy as np

array1 = np.zeros(3)
array2 = np.zeros((1, 4))
array3 = np.zeros((2, 5))

print(array1[0], array1[2])
print(array2[0][0], array2[0][3])
print(array3[1][0], array3[1][3])
-------------------------------------------------
import numpy as np

array1 = np.zeros(3)
array2 = np.zeros((1, 4))
array3 = np.zeros((2, 5))

print(array1[4]) # IndexError
print(array1[0][0]) # SyntaxError array1 is not 2D array
print(array2[2][0]) # IndexError
print(array2[1][0]) # IndexError
print(array3[3][3]) # IndexError
--------------------------------------------
import numpy as np

array1 = np.zeros(3)
array2 = np.zeros((1, 4))
array3 = np.zeros((2, 5))

print(type(array1))
print(type(array2))
print(type(array1[0]))
print(type(array2[0]))
print(type(array2[0][0]))
----------------------------------------------
import numpy as np

array1 = np.full((2, 4), 5)
print(array1)
array2 = np.full((1,5), 10)
# Here array2 is still a ndarray
print(array2)

array1 = np.full((2, 4), 5, dtype=int)
array1 = np.full((2, 4), 5, dtype=np.float64)
------------------------------------------------
import numpy as np
# arange()

array1 = np.arange(10)
array2 = np.arange(10, 20)
array3 = np.arange(10, 30, 3)

print(type(array1))
print(array1)
print(array2)
print(array3)
------------------------------------------------------
import numpy as np
# ones()

array1 = np.ones(10)
array2 = np.ones((2, 8))
array3 = np.ones((3, 5))

print(type(array1))
print(array1)
print(array2)
print(array3)
---------------------------------------------
import numpy as np

vector = np.arange(5)
print('Vector shape:', vector.shape)

matrix = np.ones([3, 2])
print('Matrix:', matrix)
print('Matrix shape:', matrix.shape)

tensor = np.zeros([2, 3, 3])
print('Tensor:', tensor)
print("Tensor shape:", tensor.shape)
-------------------------------------------------
import numpy as np

arr = np.arange(1, 10)
print(arr, '\n')

# Reshape to 3x3 matrix
arr = arr.reshape(3, 3)
print(arr, '\n')

# Reshape back to the original size
arr = arr.reshape(9) # generates 1D array
print(arr)

arr = arr.reshape(1, 9) # generates 2D array
print(arr)

arr = arr.reshape(2, 5) # ValueError
print(arr)
-----------------------------------------------------
import numpy as np

arr1 = np.arange(12)

arr2 = arr1.reshape(2, 6)
arr3 = arr1.reshape(6, 2)
arr4 = arr1.reshape(3, 4)
arr5 = arr1.reshape(12, 1)
arr6 = arr1.reshape(4, 3)

print('Arr1:\n', arr1)
print('Arr2:\n', arr2)
print('Arr3:\n', arr3)
print('Arr4:\n', arr4)
print('Arr5:\n', arr5)
print('Arr6:\n', arr6)
-------------------------------------------------------
import numpy as np

arr = np.arange(1, 10).reshape(3, -1) # Here python infers/decides the number of columns by itself.
print(arr)
-------------------------------------------------------
import numpy as np

arr1 = np.arange(1, 10) #arange always generates 1D array
arr2 = np.arange(2, 25, 2)
arr3 = arr1.reshape(3, -1) # Reshape generates 1D, 2D and 3D arrays and so on
arr4 = arr2.reshape(4, -1)
arr5 = arr2.reshape(2, -1)
arr6 = arr2.reshape(3, -1)
arr7 = arr2.reshape(-1, 4) # Numpy predicts and fixes number of rows
arr8 = arr2.reshape(-1, -1) #ValueError. Can only specify one unknown dimension

print('Arr1:\n', arr1)
print('Arr2:\n', arr2)
print('Arr3:\n', arr3)
print('Arr4:\n', arr4)
print('Arr5:\n', arr5)
print('Arr6:\n', arr6)
print('Arr7:\n', arr7)
print('Arr8:\n', arr8)
---------------------------------------------------------
import numpy as np

array1 = np.array([1, 3, 5, 0, 2, 3, 4, 5, 13, 17, 23, 29])
print(array1.shape)
print(type(array1))
print(array1)
---------------------------------------
import numpy as np

array1 = np.array([1, 3, 5, 0, 2, 3, 4, 5, 13, 17, 23, 29])

array1.shape = (6, 2)
print(array1.shape)
print(array1)

array1.shape = (3, 4)
print(array1.shape)
print(array1)

array1.shape = (4, 3)
print(array1.shape)
print(array1)

#array1.shape = (4, 2) # Error New shape of the array must consist of same number of elements as that of original array
#print(array1.shape)
#print(array1)
-------------------------------------------------
import numpy as np

matrix1 = np.array([[3, 4, 5], [2, 6, 9]])
matrix2 = np.array([[3, 4], [3, 5], [2, 6]])

matrix3 = np.dot(matrix1, matrix2)

print('Matrix3=\n', matrix3)
(r1*c1, r1*c2)
(r2*c1, r2*c2)

(3*3 + 4*3 + 5*2), (3*4 + 4*5 + 5*6)
(2*3 + 6*3 + 9*2), (2*4 + 6*5 + 9*6)

(9+12+10), (12+20+30)
(6+18+18), (8+30+54)
[ (31, 62)
  (42, 92) ]
---------------------------------------------
import numpy as np

array = np.array([2, 4, 6, 8, 9, 19])

array2 = array + 5 # Broadcasting. Adding a scalar quantity to every element of the array

print(array)
print(array2)
------------------------------------
import numpy as np

array = np.array([[2, 4, 6, 8], [9, 19, 4, 10]])

array2 = array + 5 # Broadcasting. Adding a scalar quantity to every element of the array

print(array)
print(array2)
--------------------------------------
import numpy as np

matrix1 = np.array([[3, 3, 4], [2, 3, 9]])
matrix2 = np.array([[2, 5, 4], [2, 3, 19]])

sum_matrix = matrix1 + matrix2
difference_matrix = matrix1 - matrix2
product_matrix = matrix1 * matrix2
quotient_matrix = matrix1 / matrix2

print(sum_matrix)
print(difference_matrix)
print(product_matrix)
print(quotient_matrix)
------------------------------------------
import numpy as np
import scipy

array = np.array([[1, 1, 3, 3, 4, 4, 4, 5, 7, 7, 8, 9, 12]])

mean   = np.mean(array)
median = np.median(array)
mode   = scipy.mode(array)

print(f'Mean = ', mean)
print(f'Median = ', median)
print(f'Mode = ', mode)
---------------------------------------------
num = 50

while(num < 50):
	# do something
	pass
else:
	# do something else
	pass
---------------------------------------------
To enforce elements of same type to encapsulated, we must use array from the module array
array.array stores elements of same type only.
-----------------------------------------------------

{"airline" : "akasa", "source" : "chennai", "destination" : "jaipur", 
"duration" : 3.25, "fare" : 9200, "id" : 1}

---------------------------------------------------------------
import numpy as np
def f(x, y):
	return 10 * x + y

my_aaray = np.fromfunction(f, (5, 4), dtype = int)
print(my_aaray)
------------------------------------------------------
import numpy as np
def f(x, y):
	return 10 * x + y

my_aaray = np.fromfunction(f, (5, 4), dtype = int)

# Slicing the Numpy Arrays:
print(my_aaray[2, 3]) # my_array[2][3]
print(my_aaray[0:5, 1]) # From Row-1 to Row-5, print the 2nd element
print(my_aaray[ : , 1]) # From all rows, print 2nd element
print(my_aaray[1:3, : ]) # From Row-2 to Row-3, print all elements
-------------------------------------------------------
import numpy as np

import numpy as np
def f(x, y):
	return 10 * x + y

my_array = np.fromfunction(f, (5, 4), dtype = int)

print(f'Before:\n {my_array}')
#my_array[:, [0, -1]] = 0  #For all Rows, set 0 to 1st and last columns
my_array[[0, -1], :] = 0 #For 1st row and last row, set all elements to 0

#After:
print(f'After:\n {my_array}')
----------------------------------------------------
import numpy as np

import numpy as np
def f(x, y):
	return 10 * x + y

my_array = np.fromfunction(f, (5, 4), dtype = int)

my_array[[0, 1, -1], :] = 0 #For 1st row and last row, set all elements to 0

#After:
print(f'After:\n {my_array}')
---------------------------------------------------


---------------------------------------------------
5 3
1 3 5 7 9

9  7  5  3  1

b1 = 9 * (0+1) = 9
b2 = 7 * (0+1) = 7
b3 = [5 * (0+1)] + [3 * (1+1)] + [1 * (1+1)] = 5+6+2=13
total price = 9 + 7 + 13 = 29
------------------------------------
b1 = 9 * (0+1) = 9
b2 = [7 * (0+1)] + [5 * (1+1)] = 7+10 = 17
b3 = [3 * (0+1)] + [1 * (1+1)] = 3+ 2 =  5
total price = 9 + 17 + 5 = 31
---------------------------------------
b1 = [9 * (0+1)] + [7 * (1+1)] + [5 * (1+1)] = 9 + 14 + 10 = 33
b2 = [3 * (0+1)] = 3
b3 = [1 * (0+1)] = 1
total price = 33 + 3 + 1 = 37
------------------------------------------
b1 = [9 * (0+1)] + [7 * (1+1)] +  = 9 + 14 + 10 = 33
b2 = [5 * (1+1)] + [3 * (1+1)] = 3
b3 = [1 * (0+1)] = 1

total_price = [9 * (0+1)] + [7 * (0+1)] + [5 * (0+1)] + [3 * (1+1)] + [1 * (1+1)]
total_price = 1 + 5 + 6 + 9 + 14 = 29

-----------------------------
def get_minimum_cost(k, costs):
	costs.sort(reverse=True)
	total_min_cost = 0
	n = len(costs)
	for i in range(n):
		total_min_cost += (i // k + 1) * costs[i]

	return total_min_cost

print( get_minimum_cost(3, [9, 7, 5, 3, 1]))
------------------------------------
Minimum numbers of coins for gievn amount and given denominations:

def get_minimum_coins(amount, denominations):
	denominations.sort(reverse=True)
	number_of_coins = 0
	n = len(denominations)
	i = 0
	while amount > 0:
		number_of_coins += amount // denominations[i]
		amount = amount % denominations[i]
		i += 1
	return number_of_coins

print( get_minimum_coins(88, [1, 2, 5, 20]))
-------------------------------------------------------
import numpy as np

my_array = np.zeros((8, 8), dtype = int)
#my_array[1::2, ::2] = 8
#Starting from row-index-1 and there after, for all alternatives rows, and for all columns from index 0 and there after alternative columns, replace the cells with value 8
my_array[::2, 1::2] = 1
# Odd indexed-rows Even Indexed-Columns
print(my_array)
----------------------------------------------
import numpy as np

# nan is not a number

print(0 * np.nan)
print(np.nan == np.nan)
print(np.inf > np.nan)
print(np.nan - np.nan)
print(np.nan in set([np.nan]))
print(0.3 == 3 * 0.1)
-------------------------------------------------
list1 = [2, 3, 5]

string = ' '.join(map(str, list1)) # convert a list of items of tyep other than str into a string
print(string)
print(type(string))

list2 = ['23', '55', '67']
string = ' '.join(list2) 
print(string)
-------------------------------------------------
# Create a checkerboard 8x8 matrix using the tile function 
import numpy as np

#my_matrix = np.array([[0,1],[1,0]])
#print(my_matrix)

chess_board = np.tile( np.array([[1, 0],[0, 1]]), (4,4))
# chess_board = np.tile( np.array([['*', ' '],[' ', '*']]), (4,4))
#print('\n', chess_board)

list1 = []
for array in chess_board:
    list1 = list(array)
    string = ' '.join(map(str, list1))
    print(string)
------------------------------------------------
# Normalize a 5x5 random matrix
import numpy as np

my_array = np.random.random((5,5))
#print(my_array)

values = my_array - np.mean (my_array)
print('\n', values)

values = np.std (my_array)
print('\n', values)

my_array = (my_array - np.mean (my_array)) / (np.std (my_array))
print(my_array)
-----------------------------------------------------------------
def read_heights(section):
    m = int(input(f'Enter number of girls of section-{section}: '))
    heights = []
    print(f'Enter {m} heights of girls of Section-{section}: ')
    for i in range(m):
        heights.append(int(input()))
    return heights

list1 = read_heights('A')
list2 = read_heights('B')

list1.sort()
list2.sort()
merged_list = list()

j = 0
i = 0
while i < len(list1) and j < len(list2):
    if list1[i] < list2[j]:
        merged_list.append(list1[i])
        i += 1
    else:
        merged_list.append(list2[j])
        j += 1
merged_list.extend(list1[i:])
merged_list.extend(list2[j:])

print(merged_list)
-------------------------------------------
Harry-Potter Problem

Read N (Number of gold coins)
List of N intergers (specifying value of N Gold coins)
Read Q (The Number instructions each of which is either HARRY or REMOVE
Read X (The value at which the Monk will go to sleep)

Monk goes to sleep: The sum of gold coins in Monk's bag (Stack)
Print X as O/P

'''
Read N (Number of gold coins)
List of N intergers (specifying value of N Gold coins)
Read Q (The Number instructions each of which is either HARRY or REMOVE
Read X (The value at which the Monk will go to sleep)

Monk goes to sleep: The sum of gold coins in Monk's bag (Stack)
Print X as O/P
'''

n = int(input('Enter number of Gold coins: '))
coin_values = []

print(f'Enter values of {n} Gold coins')
for i in range(n):
    coin_values.append(int(input()))

q = int(input('Enter number of instructions: '))
instructions = list()

print(f'Enter the {q} instructions')
for i in range(q):
    instructions.append(input().strip().lower())

x = int(input('Enter value of X: '))

monk_stack = []
condition_met = False

print(coin_values, '\n', instructions)

j = 0
for i in range(0, q):
    if instructions[i] == 'harry' and i < len(coin_values):
        monk_stack.append(coin_values[j])
        j += 1
    elif instructions[i] == 'remove':
        monk_stack.pop()
    if sum(monk_stack) == x:
        condition_met = True
        break #break the loop

if condition_met:
    print(f'Number of coins = {len(monk_stack)}')
else:
    print('-1')
------------------------------------------------------------
a = int(input('Enter value of a: '))
b = int(input('Enter value of b: '))
m = int(input('Enter value of m: '))

a_power_b = a ** b

remainder = a_power_b - m * (a_power_b // m)

print(f'Remainder = {remainder}')
--------------------------------------------------------
n = int(input('Enter number of test cases: '))

prime_numbers = []

print(f'Enter {n} number of PRime numbers')
for i in range(n):
    prime_numbers.append(int(input()))

for i in range(n):
    if prime_numbers[i] == 2:
        print('0 0')
    elif prime_numbers[i] == 3:
        print('1 0')
    elif prime_numbers[i] == 5:
        print('1 1')
    elif prime_numbers[i] == 7:
        print('0 1')
----------------------------------------------------------
1. Infix to Postfix Program
Where all operators are of same precedence.

2. Infix to Postfix Program
Where operators are of different precedence.

3. Infix to Postfix Program
Where operators are of different precedence and we use paranthesis to override the precedence of operators.

input_str = a - b + c

present_char = c

stk: a b -
operator: +

postfix_str = a b - c +

i = 0
until input_str has character:   # a - b + c
	if i == 0:
		stk = input_str[i]
		i++
	else:
		stk=post
		post=''
	operator = input_str[i]
	i++
	present_char = input_str[i]
	i++
	postfix_str = stk + present_char + operator
	stk = ''
	present_char = ''
	operator = ''
	
itr=1, i=0
	stk = a
	i=1
	opr= -
	i=2
	char=b
	i=3
	post=a b -
	stk=char=opr=''
itr=2, i=3
	stk=a b -
	post=''
	opr=+
	i=4
	char=c
	i=5
	post= ab-c+
	
a+b-c+m
ab+ - c + m
ab+c- + m
ab+c-m+
----------------
infix_expr = input('Enter the infix notation expression: ')

i               = 0
stk             = ''
postfix_expr    = ''
present_char    = ''
operator        = ''

for char in infix_expr:
	if i == len(infix_expr):
		break
	if i == 0:
		stk = infix_expr[i]
		i += 1
	else:
		stk = postfix_expr
		postfix_expr = ''
	operator = infix_expr[i]
	i += 1
	present_char = infix_expr[i]
	i += 1
	postfix_expr = stk + present_char + operator
	stk = ''
	present_char = ''
	operator = ''

print(f'Postfix Expression = {postfix_expr}')
----------------------------------------------------------------
Greedy Technique

https://www.hackerrank.com/challenges/greedy-florist/problem

https://docs.google.com/forms/d/1FGdHztEiiQwnIKWTeqqVO8a0kpVj8HvnXzi9BaU7erQ/edit

---------------------------------------------------
Extract digits from strings (Extract the numbers present in the string)
import re

data = ["abc123", "hello2024", "no digits", "zip007"]

# Extract digits using regex and lambda
digits = list(map(lambda s: re.findall(r'\d+', s), data))
print(digits)  # [['123'], ['2024'], [], ['007']]
------------------------
Replace all non-alphabetic characters

import re

data = ["Hello123", "A@B#C", "Clean_text", "X Y Z"]

# Remove all non-alphabetic characters
cleaned = list(map(lambda s: re.sub(r'[^a-zA-Z]', '', s), data))
print(cleaned)  # ['Hello', 'ABC', 'Cleantext', 'XYZ']

# Capitalize the whole word if it starts with a vowel
vowel_caps = list(map(lambda w: re.sub(r'^[aeiou](\w+)', w.upper(), w), words))
print(vowel_caps)
------------------------------------
Convert all email addresses to domain names

import re

emails = ["alice@gmail.com", "bob@yahoo.com", "user@outlook.com"]

# Extract domain using regex
domains = list(map(lambda s: re.search(r'@(\w+)\.com', s).group(1), emails))
print(domains)  # ['gmail', 'yahoo', 'outlook']
---------------------------------------
Capitalize words that start with vowels

import re

words = ["apple", "banana", "orange", "grape", "umbrella"]

# Capitalize if starts with a vowel
vowel_caps = list(map(lambda w: re.sub(r'^[aeiou]', lambda m: m.group(0).upper(), w), words))
print(vowel_caps)  # ['Apple', 'banana', 'Orange', 'grape', 'Umbrella']
-------------------------------------------
Replace multiple spaces with a single space

import re

texts = ["Hello   World", "Python    is great", "No extra   spaces please"]

# Normalize spaces
normalized = list(map(lambda t: re.sub(r'\s+', ' ', t), texts))
print(normalized)  # ['Hello World', 'Python is great', 'No extra spaces please']
-------------------------------------------------------
PROJECT DEVELOPMENT
SESSION-19 MONDAY 14-07-2025
Problem Statement (Abstract)
Index
Description 	  (Detailed)
Data with in the problem and relevant info and the O/P and purpose and outcome and benefits.
Plan
Design (Diagrams)
Implemnetation
Code & explanation (comments, definitions, explanation)
O/P screenshots
Closure (Brief of the project)
Bibliography
--------------------------------------------------
Store data in Python Dict
Covert it into pandas DF
Store the DF into .csv file
Read and Print the .csv file using os module libraries

Most Important Git Repo Link for your preparation for Placement Preparation
https://github.com/gmaheswaranmca/au-guvi

Flask and Django Notes and Code:
https://github.com/gmaheswaranmca/2024kitscse

Chapter5 Assessment Link:
https://docs.google.com/forms/d/1DmEP0lLygBF8YovshvTsn8dp-dPkv8qpqm-NSmZwZdo/edit

Chapter6 Assessment Link:
https://docs.google.com/forms/d/1AE7guZKFx_Ev7ZEASUCDbVarESP3Et6ImWnxacCkIOA/edit

Chapter7 Assessment Link:


Chapter8 Assessment Link:

-------------------------------------------------------------------------
groupby
Lot of rows/objects present in a table
student data

Group the students on their location
ONCE THE ROWS ARE GROUPED, WE CAN PERFORM ACTIONS ONLY THE GROUPS.
ONCE THE ROWS OF A TABLE GROUPED WE CANNOT PERFORM ACTIONS ON INDIVIDUAL ROW OF THE TABLE.
Examples: I may wish to know the count of students from each group.
I may wisht o know the average marks of each group of students
I may wish to know the total salary being paid to the groups of employees such as developers, testers, hr etc.

I may wish to know the names of the employees with highest salary from each dept of the college ????

Group the employees on dept and print the depts with number of employees more than 100 or less than 20
-------------------------------------------------------------------------
RULES FOR HACKATHON:
1. Maximum of 9 Project Statements are allowed.
2. Each Project must be taken by at least 4 students.
3. A project can be taken by maximumof 5 students.
4. A minimum of 4 and upto 6 data analysis must be demonstrated.
5. The projects must be submitted only afetr 12 pm on Wednesday 17th
6. The projects must be submitted before 4 pm on Wednesday 17th
7. The hackathon folder must be present inside the repo created for the SIC training.
8. The G-sheet will be made available for write operation to add the links by the student.
9. The Implemnetation of the same project by 4 to 5 students must be different. For this, the students implementing the same project can discuss the analysis and other features being implemneted and can distribute the BR (business requirements) yourselves.
10. Making choice of the problem statement and the features is solely left to students.
11. Once the features being implemented are finalised, student must 1st create the Detailed Problem Statement.
12. The MENU (UI) too should be different for the same project being implemented.
-----------------------------------------------------------
PENDING TOPICS:
Problem Solving: backtracking, dynamic programming
pandas and matplotlib seaborn
radix sort, heap sort, bucket sort, AVL Tree AND Sort

In an object like:

trainer {
	'name': 'nithin',
	'technology': 'python'
}

This is called as json.
Now we say,
console.log(trainer) # object with 2 fields
console.log(trainer.name)
trainer['location'] = 'mysuru'
console.log(trainer) # we get an object with 3 fields
-------------------------------
